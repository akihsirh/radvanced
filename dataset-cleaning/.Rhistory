sample_size <- 10000
counter <- 0
for(i in rnorm(sample_size)){
if(i <= 1 & i >= -1 ){
counter <- counter+1
}
}
expected_value <- counter/sample_size
expected_value
sample_size <- 100000
counter <- 0
for(i in rnorm(sample_size)){
if(i <= 1 & i >= -1 ){
counter <- counter+1
}
}
expected_value <- counter/sample_size
expected_value
sample_size <- 100000
counter <- 0
for(i in rnorm(sample_size)){
if(i <= 1 & i >= -1 ){
counter <- counter+1
}
}
expected_value <- counter/sample_size
expected_value
sample_size <- 100000
counter <- 0
for(i in rnorm(sample_size)){
if(i <= 1 & i >= -1 ){
counter <- counter+1
}
}
expected_value <- counter/sample_size
expected_value
sample_size <- 100000
counter <- 0
for(i in rnorm(sample_size)){
if(i <= 1 & i >= -1 ){
counter <- counter+1
}
}
expected_value <- counter/sample_size
expected_value
sample_size <- 100000
counter <- 0
for(i in rnorm(sample_size)){
if(i <= 1 & i >= -1 ){
counter <- counter+1
}
}
expected_value <- counter/sample_size
expected_value
sample_size <- 100000
counter <- 0
for(i in rnorm(sample_size)){
if(i <= 1 & i >= -1 ){
counter <- counter+1
}
}
expected_value <- counter/sample_size
expected_value
sample_size <- 100000
counter <- 0
for(i in rnorm(sample_size)){
if(i <= 1 & i >= -1 ){
counter <- counter+1
}
}
expected_value <- counter/sample_size
expected_value
sample_size <- 100000
counter <- 0
for(i in rnorm(sample_size)){
if(i <= 1 & i >= -1 ){
counter <- counter+1
}
}
expected_value <- counter/sample_size
expected_value
sample_size <- 100000
counter <- 0
for(i in rnorm(sample_size)){
if(i <= 1 & i >= -1 ){
counter <- counter+1
}
}
expected_value <- counter/sample_size
expected_value
sample_size <- 100000
counter <- 0
for(i in rnorm(sample_size)){
if(i <= 1 & i >= -1 ){
counter <- counter+1
}
}
expected_value <- counter/sample_size
expected_value
sample_size <- 100000
counter <- 0
for(i in rnorm(sample_size)){
if(i <= 1 & i >= -1 ){
counter <- counter+1
}
}
expected_value <- counter/sample_size
expected_value
sample_size <- 100000
for(loop in 1:5){
counter <- 0
for(i in rnorm(sample_size)){
if(i <= 1 & i >= -1 ){
counter <- counter+1
}
}
expected_value <- counter/sample_size
print
sample_size <- 100000
for(loop in 1:5){
counter <- 0
for(i in rnorm(sample_size)){
if(i <= 1 & i >= -1 ){
counter <- counter+1
}
}
expected_value <- counter/sample_size
print(expected_value)
}
MyFirstVector <- c(3,45,56,732)
MyFirstVector
is.numeric(MyFirstVector)
is.integer(MyFirstVector)
is.double(MyFirstVector)
MyFirstVector <- c(3l,45l,732l)
MyFirstVector <- c(3L,45L,732L)
MyFirstVector
is.numeric(MyFirstVector)
is.integer(MyFirstVector)
is.double(MyFirstVector)
CVec <- c("A","b","123")
CVec
is.numeric(CVec)
is.character(CVec)
S1Vec <- c("a","g",7)
S1Vec
is.numeric(S1Vec)
is.character(S1Vec)
seq(1,15)
1:15
z<- seq(1,15,4)
z
rep1 <- rep(6,21)
rep1
repc <- rep("A",35)
repc
repv <- rep(c(3,4),10)
rep1 <- rep(6,21)repv
repv
z1 <- seq(20,35,6)
z1
z2 <- seq(20:35,40)
z2 <- seq(20:21)
z2
z2
z2 <- seq(20:21)
z2
z2 <- seq(20:22)
z2
z2 <- seq(20:23)
z2
z2 <- seq(20:30)
z2
MyFirstVector[1]
MyFirstVector[3]
z[-9]
z<- seq(1,15,4)
z
z<- seq(1,15)
z
z[-9]
z[-20]
z[20]
MyFirstVector[-1:-3]
MyFirstVector[1:3]
z[4:7]
z[c(8,11,12)]
z[c(-2,-5)]
z[-3:-6]
z[-1:1]
z[seq(2:5)]
z[seq(2,5)]
z[rep(3,5)]
z[0]
z[102]
z[-102]
zero <- z[0]
zero
sv1 <- seq(1:15)
sv2 <- seq(16:20)
svadd <- sv1 + sv2
svadd
svsub <- sv2 - sv1
svsub
#Vector Arithmatics
sv1 <- seq(1,15)
sv2 <- seq(16,20)
#Vector Addition
svadd <- sv1 + sv2
svadd
svsub <- sv2 - sv1
svsub
svsub1 <- sv1 - sv2
svsub1
svmul <- sv1 * sv2
svmul
svdiv <- sv1 /sv2
svdiv
svmod <- sv2 % sv1
svmod
sv3 <- seq(1,30)
sv4 <- sv2 + sv3
sv4
sv5 <- seq(1,19)
sv6 <- sv5 + sv3
sv5 <- seq(1,19)
sv6 <- sv5 + sv3
sv6
x <- rnorm(5)
x
x <- rnorm(5)
x
for(i in x){
print(i)
}
# programming generic loop
for(j in 1:5){
print(j)
}
# R specific programming loop
for(i in x){
print(i)
}
# programming generic loop
for(j in 1:5){
print(x[j])
}
N <- 100
r <- rnorm(N)
s <- rnorm(N)
# ------------------------------- vectorized ways -----------------
N <- 100
r <- rnorm(N)
s <- rnorm(N)
#devectorized multiplication
t <- rep(NA,N)
for(i in 1:N){
t[i] <- r[i] * s[i]
}
#vectorized multiplication
u <- r * s
?seq
z<- seq(1,15,4)
z
z1 <- seq(20,35,6)
z1
z2 <- seq(20:30)
z2
z3 <- seq(from=35, to = 55, length.out = 15)
z3
seqlen <- c("q", "w","e","r","t","y")
z4 <- seq(from=35, to = 55, along.with = seqlen)
z4
repseq1 <- rep(5:6,10)
repseq1
repseq1 <- rep(5:6,times = 10)
repseq1
repseq2 <- rep(5:6,each = 10)
repseq2
b <- sqrt(repseq1)
b
setwd("C:/Git/R Programming Exercises/radvanced/dataset-cleaning")
TRUE == TRUE
TRUE == FALSE
FALSE == FALSE
TRUE == 1
FALSE == 0 #TRUE
TRUE == 14 # FALSE
FALSE == 5 # FALSE
NA == FALSE #NA
NA == 13 # NA
NA == NA # NA
#Complete cases function helps find rows in data with atleast one missing data col
complete.cases(fin)
getwd()
setwd("C:/Git/R Programming Exercises/radvanced/dataset-cleaning")
fin <- read.csv("Future500.csv")
head(fin)
str(fin)
#Convert from non factor to factor
fin$ID <- factor(fin$ID)
fin$Inception <- factor(fin$Inception)
#Cleaning up extra symbols from data such as 'Dollars', '$' and ','
typeof(fin$Revenue)
head(fin)
#Clean up Expenses column
fin$Expenses <- gsub(" Dollars","",fin$Expenses)
fin$Expenses <- gsub(",","",fin$Expenses)
head(fin)
str(fin)
#Clean up Revenue
fin$Revenue <- gsub("\\$","",fin$Revenue)
head(fin)
str(fin)
fin$Revenue <- gsub(",","",fin$Revenue)
head(fin)
str(fin)
#Clean up Growth
fin$Growth <- gsub("%","",fin$Growth)
head(fin)
str(fin)
# Convert the cleaned up columns back from character into a proper type.Notice that
# gsub converted the factor columns into characcter for us
fin$Growth <- as.numeric(fin$Growth)
fin$Expenses <- as.numeric(fin$Expenses)
fin$Revenue <- as.numeric(fin$Revenue)
head(fin)
str(fin)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~ Dealing with missing data
# 1. Predict with 100% accuracy
# 2. Leave a record as it is - when a field is not required for analysis or when the data
# has a way to account for missing data
# 3. Remove missing data records - disadv ---> incomplete analysis or little records
# 4. Replace with mean or median. Median is preferred because its not affected by outliers
# 5. Predict data based on correlations. Step up of above step
# 6. Give it a dummy value
### Locating missing data
# Find rows with atleast one incomplete data column
#Complete cases function helps find rows in data with atleast one missing data col
complete.cases(fin)
#use above to find rows that dont have
fin[!complete.cases(fin),]
getwd()
setwd("C:/Git/R Programming Exercises/radvanced/dataset-cleaning")
# Basic import --> fin <- read.csv("Future500.csv")
# Import that deals with missing data
fin <- read.csv("Future500.csv", na.strings = c(""))
head(fin)
str(fin)
#Convert from non factor to factor
fin$ID <- factor(fin$ID)
fin$Inception <- factor(fin$Inception)
#Cleaning up extra symbols from data such as 'Dollars', '$' and ','
typeof(fin$Revenue)
head(fin)
#Clean up Expenses column
fin$Expenses <- gsub(" Dollars","",fin$Expenses)
fin$Expenses <- gsub(",","",fin$Expenses)
head(fin)
str(fin)
#Clean up Revenue
fin$Revenue <- gsub("\\$","",fin$Revenue)
head(fin)
str(fin)
fin$Revenue <- gsub(",","",fin$Revenue)
head(fin)
str(fin)
#Clean up Growth
fin$Growth <- gsub("%","",fin$Growth)
head(fin)
str(fin)
# Convert the cleaned up columns back from character into a proper type.Notice that
# gsub converted the factor columns into characcter for us
fin$Growth <- as.numeric(fin$Growth)
fin$Expenses <- as.numeric(fin$Expenses)
fin$Revenue <- as.numeric(fin$Revenue)
head(fin)
str(fin)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~ Dealing with missing data
# 1. Predict with 100% accuracy
# 2. Leave a record as it is - when a field is not required for analysis or when the data
# has a way to account for missing data
# 3. Remove missing data records - disadv ---> incomplete analysis or little records
# 4. Replace with mean or median. Median is preferred because its not affected by outliers
# 5. Predict data based on correlations. Step up of above step
# 6. Give it a dummy value
### Locating missing data
# Find rows with atleast one incomplete data column
#Complete cases function helps find rows in data with atleast one missing data col
# vector is returned with FALSE value against rows that have missing data
complete.cases(fin)
#use above to find rows that have incomplete data
# PS :- This function only detects cases where the empty column is represented by NA
# If the column is blank it wont detect that as a row with missing data
fin[!complete.cases(fin),]
?source
getwd()
getwd()
setwd("C:/Git/R Programming Exercises/radvanced/dataset-cleaning")
source("DatasetCleaning-1.R")
getwd()
setwd("C:/Git/R Programming Exercises/radvanced/dataset-cleaning")
source("DatasetCleaning-1.R")
#which() for missing data
#which() for missing data
head(fin)
#Get data without using which for a condition
fin[fin$Profit == 8553827]
#Get data without using which for a condition
fin[fin$Profit == 8553827, ]
# to remove all the NA cases use which()
which(fin$Profit == 8553827)
fin[which(fin$Profit == 8553827), ]
#Another example
fin[fin$Employees == 45, ]
fin[which(fin$Employees == 45), ]
#Using column value == NA method
fin[fin$Employees == NA, ]
is.na(fin$Employees)
fin[is.na(fin$Employees) , ]
#Create data backup
fin_bckp <- fin
#Industry info is imp so we 1st need to remove all rows where industry info is missing
fin <- fin[ !is.na(fin$Industry) , ]
#resetting the data frame index i.e adjust row numbers after NA row deletion
#Note that we are not changing the value of the column ID but the dataset row nos.
rownames(fin) <- 1:nrow(fin)
fin
fin
#Another method
rownames(fin) <- NULL
fin
# Replacing missing data : Factual analysis method - here you basically try to fill
# out the missing data for columns where you know the values for sure
fin[is.na(fin$State) , ]
#Fill out rows with New York state code missing
fin[is.na(fin$State) & fin$City == "New York", "City"] <- "NY"
fin
#Find out the rows with missing state code info
fin[is.na(fin$State) , ]
#Fill out rows with New York state code missing
fin[is.na(fin$State) & fin$City == "New York", "City"] <- "New York"
fin[is.na(fin$City) , ]
#Fill out rows with New York state code missing
fin[is.na(fin$City) , ] <- "New York"
fin
fin[is.na(fin$City) , ]
fin <- fin_bckp
fin[is.na(fin$State) , ]
# Dealing with missing data
# get slightly cleaned up data
getwd()
setwd("C:/Git/R Programming Exercises/radvanced/dataset-cleaning")
source("DatasetCleaning-1.R")
#Create data backup
fin_bckp <- fin
#Industry info is imp so we 1st need to remove all rows where industry info is missing
fin <- fin[ !is.na(fin$Industry) , ]
#resetting the data frame index i.e adjust row numbers after NA row deletion
#Note that we are not changing the value of the column ID but the dataset row nos.
# Manually set the rownames based on rowcount
rownames(fin) <- 1:nrow(fin)
fin
#Another method
rownames(fin) <- NULL
fin <- fin_bckp
# Replacing missing data : Factual analysis method - here you basically try to fill
# out the missing data for columns where you know the values for sure
#Find out the rows with missing state code info
fin[is.na(fin$State) , ]
#Fill out rows with New York state code missing
#Fill out rows with New York state code missing
fin[is.na(fin$State) & fin$City == "New York", "State"] <- "NY"
fin[is.na(fin$State) , ]
fin[fin$City == "San Francisco", "State"]
fin[fin$City == "San Francisco", ]
#Fill out rows with New York state code missing
fin[is.na(fin$State) & fin$City == "San Francisco", "State"] <- "CA"
fin[is.na(fin$State) , ]
fin[c(82,265)]
fin[c(82,265),]
#Check for rows with missing data
fin[!complete.cases(fin), ]
# Dealing with missing data
# get slightly cleaned up data
getwd()
setwd("C:/Git/R Programming Exercises/radvanced/dataset-cleaning")
source("DatasetCleaning-1.R")
#Create data backup
fin_bckp <- fin
#Industry info is imp so we 1st need to remove all rows where industry info is missing
fin <- fin[ !is.na(fin$Industry) , ]
#resetting the data frame index i.e adjust row numbers after NA row deletion
#Note that we are not changing the value of the column ID but the dataset row nos.
# Manually set the rownames based on rowcount
rownames(fin) <- 1:nrow(fin)
fin
#Another method
rownames(fin) <- NULL
# Replacing missing data : Factual analysis method - here you basically try to fill
# out the missing data for columns where you know the values for sure
#Find out the rows with missing state code info
fin[is.na(fin$State) , ]
#Fill out rows with New York state code missing
fin[is.na(fin$State) & fin$City == "New York", "State"] <- "NY"
fin[is.na(fin$State) , ]
#Fill out rows with New York state code missing
fin[is.na(fin$State) & fin$City == "San Francisco", "State"] <- "CA"
fin[is.na(fin$State) , ]
fin[c(82,265),]
#Check for rows with missing data
fin[!complete.cases(fin), ]
